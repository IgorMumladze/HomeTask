name: deploy-ecs

on:
  workflow_dispatch:
    inputs:
      deploy_api:
        description: "Deploy API service"
        type: boolean
        default: true
      deploy_worker:
        description: "Deploy worker service"
        type: boolean
        default: true
      image_tag:
        description: "Image tag to roll to (defaults to latest)"
        required: false
        default: "latest"
      health_endpoints:
        description: "Comma-separated health endpoints (optional; falls back to secret HEALTH_ENDPOINTS)"
        required: false
        default: ""
  workflow_run:
    workflows: ["build-and-push-ecr"]
    types:
      - completed

concurrency: ecs-deploy-${{ github.ref }}

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  CLUSTER_NAME: "igor-home-task-prod-cluster"
  API_SERVICE_NAME: "igor-home-task-prod-api-service"
  WORKER_SERVICE_NAME: "igor-home-task-prod-worker-service"
  WAIT_FOR_STABLE: "false"
  HEALTH_TIMEOUT: "360"  # seconds
  HEALTH_PER_REQUEST_TIMEOUT: "10"
  HEALTH_MIN_SUCCESS: "2"
  HEALTH_ENDPOINTS: ${{ inputs.health_endpoints != '' && inputs.health_endpoints || secrets.HEALTH_ENDPOINTS }}
  IMAGE_TAG: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || inputs.image_tag }}
  DEPLOY_API: ${{ github.event_name == 'workflow_run' && 'true' || inputs.deploy_api }}
  DEPLOY_WORKER: ${{ github.event_name == 'workflow_run' && 'true' || inputs.deploy_worker }}

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    env:
      CLOUDWATCH_NAMESPACE: HomeTask/CICD
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (static)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Show image tag to deploy
        run: |
          echo "Using image tag: ${IMAGE_TAG}"

      - name: Capture current task definitions
        run: |
          set -euo pipefail
          if [ "${DEPLOY_API}" = "true" ]; then
            API_TD=$(aws ecs describe-services --cluster "${CLUSTER_NAME}" --services "${API_SERVICE_NAME}" --query "services[0].taskDefinition" --output text)
            echo "OLD_API_TASKDEF=$API_TD" >> $GITHUB_ENV
          fi
          if [ "${DEPLOY_WORKER}" = "true" ]; then
            WORKER_TD=$(aws ecs describe-services --cluster "${CLUSTER_NAME}" --services "${WORKER_SERVICE_NAME}" --query "services[0].taskDefinition" --output text)
            echo "OLD_WORKER_TASKDEF=$WORKER_TD" >> $GITHUB_ENV
          fi

      - name: Register task definitions with image tag
        run: |
          set -euo pipefail

          register_with_tag () {
            local td_arn="$1"
            local out_var="$2"
            echo "Registering new task definition from ${td_arn} with tag ${IMAGE_TAG}"
            tmp=$(mktemp)
            aws ecs describe-task-definition --task-definition "$td_arn" --query 'taskDefinition' --output json > "$tmp"
            # update image tags and strip read-only fields
            jq --arg tag "${IMAGE_TAG}" '
              del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) |
              .containerDefinitions |= (map(.image |= (. | split(":")[0] + ":" + $tag)))
            ' "$tmp" > "${tmp}.out"
            NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://${tmp}.out --query taskDefinition.taskDefinitionArn --output text)
            echo "${out_var}=${NEW_TD_ARN}" >> $GITHUB_ENV
            rm -f "$tmp" "${tmp}.out"
          }

          if [ -n "${OLD_API_TASKDEF:-}" ]; then
            register_with_tag "${OLD_API_TASKDEF}" "NEW_API_TASKDEF"
          fi
          if [ -n "${OLD_WORKER_TASKDEF:-}" ]; then
            register_with_tag "${OLD_WORKER_TASKDEF}" "NEW_WORKER_TASKDEF"
          fi

      - name: Deploy selected services
        run: |
          set -euo pipefail
          deploy() {
            local svc="$1"
            local td_env="$2"
            local td="${!td_env:-}"
            if [ -z "$td" ]; then
              echo "No task definition ARN found for ${svc}, skipping"
              return
            fi
            echo "Forcing new deployment for ${svc}..."
            aws ecs update-service \
              --cluster "${CLUSTER_NAME}" \
              --service "${svc}" \
              --task-definition "${td}" \
              --force-new-deployment
          }

          if [ "${DEPLOY_API}" = "true" ]; then
            deploy "${API_SERVICE_NAME}" "NEW_API_TASKDEF"
          else
            echo "Skipping API service (deploy_api=false)"
          fi

          if [ "${DEPLOY_WORKER}" = "true" ]; then
            deploy "${WORKER_SERVICE_NAME}" "NEW_WORKER_TASKDEF"
          else
            echo "Skipping Worker service (deploy_worker=false)"
          fi

          if [ "${WAIT_FOR_STABLE}" = "true" ]; then
            echo "Waiting for services to stabilize..."
            aws ecs wait services-stable \
              --cluster "${CLUSTER_NAME}" \
              --services "${API_SERVICE_NAME}" "${WORKER_SERVICE_NAME}"
          else
            echo "Skipping wait (WAIT_FOR_STABLE=${WAIT_FOR_STABLE})"
          fi

      - name: Service health check
        id: health
        continue-on-error: true
        run: |
          set -euo pipefail
          python .github/scripts/http_health_check.py

      - name: Roll back on failed health
        if: ${{ steps.health.outcome == 'failure' }}
        run: |
          set -euo pipefail
          echo "Health check failed, rolling back to previous task definitions..."
          if [ -n "${OLD_API_TASKDEF:-}" ]; then
            aws ecs update-service \
              --cluster "${CLUSTER_NAME}" \
              --service "${API_SERVICE_NAME}" \
              --task-definition "${OLD_API_TASKDEF}"
          fi
          if [ -n "${OLD_WORKER_TASKDEF:-}" ]; then
            aws ecs update-service \
              --cluster "${CLUSTER_NAME}" \
              --service "${WORKER_SERVICE_NAME}" \
              --task-definition "${OLD_WORKER_TASKDEF}"
          fi
          echo "Waiting for rollback to stabilize..."
          aws ecs wait services-stable \
            --cluster "${CLUSTER_NAME}" \
            --services "${API_SERVICE_NAME}" "${WORKER_SERVICE_NAME}"
          exit 1  # fail the job to signal rollback happened

      - name: Publish deploy success metric
        if: success()
        run: |
          aws cloudwatch put-metric-data \
            --namespace "$CLOUDWATCH_NAMESPACE" \
            --metric-data \
              MetricName=DeploySuccess,Dimensions=[{Name=Workflow,Value=deploy-ecs}],Value=1,Unit=Count

      - name: Publish deploy failure metric
        if: failure()
        run: |
          aws cloudwatch put-metric-data \
            --namespace "$CLOUDWATCH_NAMESPACE" \
            --metric-data \
              MetricName=DeployFailure,Dimensions=[{Name=Workflow,Value=deploy-ecs}],Value=1,Unit=Count
